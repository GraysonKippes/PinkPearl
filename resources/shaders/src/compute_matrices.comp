#version 450

// This compute shader takes in an array of vectors (representing positions),
// and creates translation matrices. Then each matrix is multiplied by the camera
// and projection matrices, and push to an output buffer.

#define MAX_SIZE_X 64

layout(local_size_x = MAX_SIZE_X) in;

// TODO - specify std140 memory layout.
layout(binding = 0) uniform uniform_data_t {

	uint num_inputs;

	float delta_time;

	// TODO - make this a struct for better memory packing.
	float projection_left;
	float projection_right;
	float projection_bottom;
	float projection_top;
	float projection_near;
	float projection_far;

	vec3 camera_position;
	vec3 camera_previous_position;

	vec3 positions[MAX_SIZE_X];
	vec3 previous_positions[MAX_SIZE_X];
	
} uniform_data;

layout(binding = 1) writeonly buffer output_buffer {
	mat4 matrices[MAX_SIZE_X];
} output_data;

// Makes and returns a "translerp" (portmanteau of "translate" and "lerp") matrix.
mat4 make_translerp_matrix(vec3 position, vec3 previous_position, float delta_time) {

	vec3 lerp_position = vec3(
		mix(previous_position.x, position.x, delta_time),
		mix(previous_position.y, position.y, delta_time),
		mix(previous_position.z, position.z, delta_time));
	
	
	mat4 translation_matrix;
	translation_matrix[0] = vec4(1.0, 0.0, 0.0, 0.0);
	translation_matrix[1] = vec4(0.0, 1.0, 0.0, 0.0);
	translation_matrix[2] = vec4(0.0, 0.0, 1.0, 0.0);
	translation_matrix[3] = vec4(lerp_position, 1.0);

	return translation_matrix;
}

// Makes and returns an orthographic projection matrix.
mat4 make_orthographic_projection_matrix(float left, float right, float bottom, float top, float near, float far) {
	
	float scale_x = 2.0 / (right - left);
	float scale_y = 2.0 / (top - bottom);
	float scale_z = -2.0 / (far - near);

	float mid_x = (right + left) / (right - left);
	float mid_y = (top + bottom) / (top - bottom);
	float mid_z = (far + near) / (far - near);

	mat4 projection_matrix;
	projection_matrix[0] = vec4(scale_x, 0.0, 0.0, 0.0);
	projection_matrix[1] = vec4(0.0, scale_y, 0.0, 0.0);
	projection_matrix[2] = vec4(0.0, 0.0, scale_z, 0.0);
	projection_matrix[3] = vec4(-mid_x, -mid_y, -mid_z, 1.0);

	return projection_matrix;
}

void main() {
	
	uint global_ID = gl_GlobalInvocationID.x;

	mat4 camera_matrix = make_translerp_matrix(uniform_data.camera_position, uniform_data.camera_previous_position, uniform_data.delta_time);

	mat4 projection_matrix = make_orthographic_projection_matrix(uniform_data.projection_left, uniform_data.projection_right, uniform_data.projection_bottom, uniform_data.projection_top, uniform_data.projection_near, uniform_data.projection_far);

	if (global_ID < uniform_data.num_inputs) {
		mat4 model_matrix = make_translerp_matrix(uniform_data.positions[global_ID], uniform_data.previous_positions[global_ID], uniform_data.delta_time);
		output_data.matrices[global_ID] = projection_matrix * camera_matrix * model_matrix;
	}
}
