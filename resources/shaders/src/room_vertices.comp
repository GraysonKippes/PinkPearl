#version 450

#define MAX_LOCAL_SIZE_X 32	// Corresponds to room width.
#define MAX_LOCAL_SIZE_Y 20	// Corresponds to room height.

layout(local_size_x = MAX_LOCAL_SIZE_X, local_size_y = MAX_LOCAL_SIZE_Y, local_size_z = 1) in;

#define NUM_VERTICES_PER_TILE 4	// Number of vertices per tile.
#define STRIDE_ELEMENTS 7	// The number of elements per vertex.

layout(set = 0, binding = 0) uniform config {
	
	uint room_width;
	uint room_length;

	// If this is true, then the vertices are written to a secondary location in the buffer.
	bool buffer_offset;

} op_data;

struct tile_data_t {
	uint m_num_tiles;
	uint m_tile_ID;
};

layout(set = 0, binding = 1) writeonly buffer output {
	float vertices[];
	tile_data_t tile_data[];
} output_data;

void main() {

	uint room_size = op_data.room_width * op_data.room_length;
	uint local_index = gl_LocalInvocationIndex;

	if (local_index < room_size) {

		uint offset = local_index * NUM_VERTICES_PER_TILE * STRIDE_ELEMENTS;

		/* -- POSITION -- */

		uint pos_x = gl_LocalInvocationID.x;
		uint pos_y = gl_LocalInvocationID.y;

		// Vertex 0
		output_data.vertices[offset + 0] = pos_x - (op_data.room_width / 2.0);
		output_data.vertices[offset + 1] = pos_y - (op_data.room_height / 2.0);
		output_data.vertices[offset + 2] = 1.0;

		// Vertex 1
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];

		// Vertex 2
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];

		// Vertex 3
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];
		output_data.vertices[offset + 0];

		/* -- TEXTURE COORDINATES -- */
		output_data.vertices[offset + 3];
		output_data.vertices[offset + 4];

		// Color
		output_data.vertices[offset + 5] = 1.0;
		output_data.vertices[offset + 6] = 1.0;
		output_data.vertices[offset + 7] = 1.0;
	}
}
