#version 450

// Generates the base texture for the room.
// Takes the tilemap slot for each tile in the room and copies it to the appropriate spot in the final texture.
// Tiles are split up across workgroups, as the number of tiles is variable.
//	The x-dimension represents room width.
//	The y-dimension represents room height.
//	gl_WorkGroupID = (0, 0) indicates the top-left corner.
// Texels within each tilemap slot are split up across local groups, as the dimensions are fixed (16x16).

// VERSION 2: generates position map.

// Each tile has a position in 3D room render space; that is, position relative to the room scene.
// This in constrast with the position of the tile in the 2D room texture space; 
//	that is, where the tile's texture in the room texture;
// and in contrast with the position of the tile in 3D game space.
// Render space has [-x, -y] for top-left and [+x, +y] for bottom-right,
//	whereas game space has [-x, -y] for bottom-left and [+x, +y] for top-right.
// Models are transformed from game space to render space by multiplication by the y-axis inversion matrix:
//
//	| 1  0 0 0 |
//	| 0 -1 0 0 |
//	| 0  0 1 0 |
//	| 0  0 0 1 |
//
// Since models end up in render space anyways, tile positions are presented in render space as well,
//	with the caveat that they are relative to the room, not to whole world space.

#define MAX_SIZE_X 16	// Tile texture width
#define MAX_SIZE_Y 16	// Tile texture height
#define MAX_SIZE_Z 1

// 32 * 20
#define MAX_NUM_TILES 640

layout(local_size_x = MAX_SIZE_X) in;
layout(local_size_y = MAX_SIZE_Y) in;
layout(local_size_z = MAX_SIZE_Z) in;

struct tile_t {

	// Position of this tile's texture within the tilemap texture atlas.
	uint tilemap_slot;

	// Position of this tile within 3D room space.
	uvec3 position;

} tile_t;

layout(set = 0, binding = 0, std140) uniform tile_data_t {

	// Volume of the room scene in cubic tiles.
	// X = width, [-12, 12]
	// Y = length, [-7.5, 7.5]
	// Z = height (towards the camera)
	uvec3 scene_extent;

	// length = room width * room height
	// use workgroup ID index into this array
	tile_t tiles[MAX_NUM_TILES];

} tile_data;

layout(set = 0, binding = 1, rgba8ui) uniform readonly uimage2DArray tilemap_texture;

// Width should be room width * 16 in texels.
// Height should be room height * 16 in texels.
layout(set = 0, binding = 2, rgba8ui) uniform writeonly uimage2D room_texture;
layout(set = 0, binding = 3, rgba8ui) uniform writeonly uimage2D room_texture_position_map;
layout(set = 0, binding = 4, rgba8ui) uniform writeonly uimage2D room_texture_rotation_map;
layout(set = 0, binding = 5, rgba8ui) uniform writeonly uimage2D room_texture_pbr_map;

void main() {

	// Row-major computation order.

	// The index of the tile whose texture is currently being generated.
	uint tile_index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
	uint tilemap_slot = tile_data.tiles[tile_index].tilemap_slot;
	ivec2 tilemap_size = (imageSize(tilemap_texture) / 16).xy;
	ivec2 tilemap_slot_coords = ivec2(tilemap_slot % tilemap_size.x, tilemap_slot / tilemap_size.x);

	ivec2 input_coords = tilemap_slot_coords * 16 + ivec2(gl_LocalInvocationID.xy);
	ivec2 output_coords = ivec2(gl_WorkGroupID.xy * 16 + gl_LocalInvocationID.xy);

	uvec4 texel = imageLoad(tilemap_texture, ivec3(input_coords, 0));
	uvec4 texel_position_map = uvec4(tiles[tile_index].position / scene_extent, 1.0);


	imageStore(room_texture, output_coords, texel);
}
